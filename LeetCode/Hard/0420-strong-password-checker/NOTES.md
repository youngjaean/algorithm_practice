1. 강력한 password를 충족하기 위해선
2. 대문자 1개 소문자1개 번호 1개 이상이 필요하며 6~20글자 사이여야함
3.  예외 중복된 글자가 3개 이상 연속으로 반복시 강한 비밀번호가 아님
4.  이미 강한 비밀번호면 0을 리턴


~~중복을 확인하는법 -> 이게 이문제의 핵심~~
~~- 일차 아이디어로 for문을 모두 돌려 3인 경우 count1을 진행 이유는 가운데만 바꿔주면 되니까~~
~~- 만약 중복이 7글자면, 1글자 빠지니까... len은 안걸림 -> 이를 위해 중복 체크를 가장 먼저 해주고 이를 통해 중복 문자 1개 제거~~
- 여기서 헷갈리는거, 무조건 제거인지, 6개 넘으면 제거인지?
~~- 일단 6개 또는 20개 넘은경우만 제거하기로~~
~~대문자 소문자 번호는 in을 통해서 존재하는지 검사하면됨~~
~~글자 길이는 len을 통해서 즉 이 세개를 한꺼번에 통과하면되며, 이 조건들이 개별로 돌아가서 count를 하면됨 예를 들어 대문자 소문자 두개가 없으면 count += 1 랭스가 6보다 작은 3이면 +3 등~~
~~실제로 하나씩 변경해야함~~
~~조건을 하나씩 만 봣을땐 처음과 같이 단순한데 여기서 문제는, 중복된 경우 내가 임의적으로 부족한 글자로 채울 수가 있음 aaa123 인경우 aBa123으로 바꾸면 한번만 바꾸면됨~~
~~근데 단순하게 생각햇을~~
~~aaa123 -> 중복 제거 count ,이후 대문자가 없기 때문에 aBa123으로 count가 추가됨~~ 


1. 강력한 password를 충족하기 위해선
2. 대문자 1개 소문자1개 번호 1개 이상이 필요하며 6~20글자 사이여야함
3.  예외 중복된 글자가 3개 이상 연속으로 반복시 강한 비밀번호가 아님
4.  이미 강한 비밀번호면 0을 리턴

4번은 무시해도 좋은 조건 나머지가 충족된다면 자동으로 0이 반환됨
1. 내부에 upper가 없는지 num이 없는지 lower가 없는지를 체크하여 값을 변환함.
~~2. 이때 길이가 6보다 작으면 부족한 값을 채우게 되고, 길이가 20보다 크다면 넘치는 값들을 제거해야함~~
3. 중복 체크 도중 조건이 나오면 값을  추가하는 방식이 맞을듯하고 중복 체크를 진행하면서 list화
4. 그럼 6이 안되는 경우 20이 넘는 경우를 체크할 수 있음
5. 6 이하의 경우false인 값을 먼저 채워 넣어 passwor를 만듬
6. 20 이상인 경우 중복 체크할때 사전 제거
6. 위의 경우가 아닌경우 false를 true로 만들어줌
7. 

위의 조건대로 작성할시, 최적의 값이 나오기 힘들다 왜냐면 그리드에 가까운 느낌으로 풀었으니까
해는 여러개 나온다,이때 최적을 찾기위해 즉 다이나믹 프로그래밍을 사용해야한다​

다른 사람 코드를 참고하여 해결했지만 해결 자체는 거의다 했지만, 중간 중간 연결이 부족했고, 경험부족이 컸다.
예를 들면 문제에서 어떠한 방법으로든 한번 해결되고 나면 count가 +1 되는 경우라던지 (길이가 짧았을때 짧은 만큼 올릴게 아니라..).. 혹은 중복을 제거하면서 해결할 수 있으면 그걸로 끝낸다던지
결국 최적의 해를 찾는 문제로 접근했어야함 문제가 조금 불친절하다 느껴짐 
